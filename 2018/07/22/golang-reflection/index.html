<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="golang," />





  <link rel="alternate" href="/atom.xml" title="一期一会" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="近期在为bingo框架添砖加瓦，用到了golang的反射。这篇文章解决了我不少疑难杂症，特分享给大家。">
<meta property="og:type" content="article">
<meta property="og:title" content="golang反射三法则">
<meta property="og:url" content="http://blog.jonnydu.me/2018/07/22/golang-reflection/index.html">
<meta property="og:site_name" content="一期一会">
<meta property="og:description" content="近期在为bingo框架添砖加瓦，用到了golang的反射。这篇文章解决了我不少疑难杂症，特分享给大家。">
<meta property="article:published_time" content="2018-07-22T11:26:20.000Z">
<meta property="article:modified_time" content="2020-04-30T14:16:30.252Z">
<meta property="article:author" content="jonnydu">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '一期一会'
    }
  };
</script>

  <title> golang反射三法则 | 一期一会 </title>
<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一期一会</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="st-search-show-outputs">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'CFymCPjb2LHwhFXVjxQk','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                golang反射三法则
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2018-07-22T19:26:20+08:00" content="2018-07-22">
              2018-07-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2018/07/22/golang-reflection/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2018/07/22/golang-reflection/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>近期在为bingo框架添砖加瓦，用到了golang的反射。这篇文章解决了我不少疑难杂症，特分享给大家。</p>
<a id="more"></a>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>在计算机科学里，反射是程序，特别是通过类型，查看并操纵其自身结构的能力。 它是元编程的一种形式，同时也是最容易让人误解的部分。<br>在本文中，我们试图解释反射在 Go 中是如何工作，希望能澄清对它的误解。每一种语言的发射模型都不同 （甚至许多语言根本不支持反射），不过既然这篇文章是关于 Go 的，因此在接下来的内容中， “反射”一词应理解成“Go 中的反射”。</p>
<h3 id="类型与接口"><a href="#类型与接口" class="headerlink" title="类型与接口"></a>类型与接口</h3><p>由于反射建立在类型系统之上，就让我先来复习一下 Go 语言里的类型吧。<br>Go是静态类型的语言。每个变量都有一种静态类型。换言之，他们的类型在 编译期就确定并且固定下来了。 比如 int 、 float32 、 *MyType 或 []byte 等等。如果我们定义了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> j MyInt</span><br></pre></td></tr></table></figure>
<p>那么i 的类型为 int ，而 j 的类型为 MyInt 。尽管变量 i 和 j 拥有相同的基本类型， 但它们的静态类型仍然不同，因此在它们未经转换前是不能相互赋值的。<br>在类型中，有一种重要的类别就是接口类型，它表示一个确定的方法集。只要某个具体值 （非接口）实现了某个接口中的方法，该接口类型的变量就能存储它。一对众所周知的例子就是 io.Reader 和 io.Writer ，即 io 包中的 Reader 和 Writer 类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reader is the interface that wraps the basic Read method.</span></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任何实现了 Read （或 Write ）方法及其签名的类型， 同时也就实现了 io.Reader （或 io.Writer ）接口。 就此而言，若某个值的类型拥有 Read 方法， io.Reader 类型的变量就能保存它：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">r = os.Stdin</span><br><span class="line">r = bufio.NewReader(r)</span><br><span class="line">r = <span class="built_in">new</span>(bytes.Buffer)</span><br></pre></td></tr></table></figure>
<p>有件事一定要明确，即无论 r 保存了什么具体的值， r 的类型总是 io.Reader ：Go是静态类型的，而 r 的静态类型为 io.Reader 。<br>一个非常重要的接口类型是空接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>它表示空方法集。由于任何值都有零或多个方法，因此任何值都满足它。<br>有人说Go的接口是动态类型的，不过这是种误解。它们确实是静态类型的： 接口类型的变量总有着相同的静态类型，就算存储在其中的值的类型在运行时可能会改变， 它也总是满足该接口。<br>对于所有的这些，我们都必须严谨对待，因为反射和接口密切相关。</p>
<h3 id="接口的表示"><a href="#接口的表示" class="headerlink" title="接口的表示"></a>接口的表示</h3><p>Russ Cox 写过一篇题为<a href="http://research.swtch.com/2009/12/go-data-structures-interfaces.html" target="_blank" rel="noopener">Go中接口值的表示</a>的文章，我们就不在此赘述了。不过简单概括一下还是很有必要的。<br>接口类型的变量存储了一对内容：赋予该变量的具体值，以及该值的类型描述符。 更准确地说，其值是实现了该接口的具体数据条目，而其类型则描述了该条目的完整类型。 例如，在执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r io.Reader</span><br><span class="line">tty, err := os.OpenFile(<span class="string">"/dev/tty"</span>, os.O_RDWR, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">r = tty</span><br></pre></td></tr></table></figure>
<p>之后，如果按形式来描述，那么 r 就包含了 (值, 类型) 对，即 ( tty, *os.File )。注意，类型 *os.File 还实现了除 Read 以外的其它方法：尽管该接口值只提供了访问 Read 方法的能力，但其内部却携带了有关该值的所有类型信息。 这就是我们可以这样做的原因：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = r.(io.Writer)</span><br></pre></td></tr></table></figure>
<p>在此赋值语句中的表达式是一个类型断言：它断言 r 内的条目同时也实现了 io.Writer ，因此我们可以将它赋予 w 。 赋值后， w 将会包含一对 ( tty , *os.File )。 这与保存在 r 中的一致。接口的静态类型决定了哪些方法可通过接口变量调用， 即便其内部具体的值可能有更大的方法集。<br>接着，我们可以这样做：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">empty = w</span><br></pre></td></tr></table></figure>
<p>而我们的空接口值 e 也将再次包含同样的一对 ( tty, *os.File )。 这很方便：空接口可保存任何值，并包含关于该值的所有信息。<br>（在这里我们无需类型断言，因为 w 肯定是满足空接口的。在本例中， 我们将一个值从 Reader 变成了 Writer ，由于 Writer 的方法并非 Reader 的子集，因此我们必须显式地使用类型断言。）<br>一个很重要的细节，就是接口内部的对总是 (值, 具体类型) 的形式，而不会是 (值, 接口类型) 的形式。接口不能保存接口值。<br>现在我们准备好聊聊反射了。</p>
<h3 id="反射法则一：反射是从接口值到反射对象"><a href="#反射法则一：反射是从接口值到反射对象" class="headerlink" title="反射法则一：反射是从接口值到反射对象"></a>反射法则一：反射是从接口值到反射对象</h3><p>从基本层面上看，反射只是一种检查存储在接口变量中的“类型-值对”的机制。 首先，我们需要了解reflect包中的两种类型：Type和Value。这两种类型可用来访问接口变量的内容。 还有两个简单的函数，叫做reflect.TypeOf 和 reflect.ValueOf ， 它们用于接口值中分别获取 reflect.Type 和 reflect.Value 。 同样，从 reflect.Value 也能很容易地获取 reflect.Type ， 不过让我们先保持 Value 和 Type 概念的独立性吧。<br>我们先从 TypeOf 开始：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">    fmt.Println(<span class="string">"type:"</span>, reflect.TypeOf(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此程序会打印出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>: <span class="keyword">float64</span></span><br></pre></td></tr></table></figure>
<p>你可能会问接口在哪，因为该程序看起来只是向 reflect.TypeOf 传递了一个 float64 类型的变量 x ，而不是一个接口值。但它就在那， reflect.TypeOf 的签名包含了一个空接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeOf 返回 interface&#123;&#125; 中的值的反射类型 Type。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure>
<p>当我们调用 reflect.TypeOf(x) 时， x 首先会被存储在一个空接口中， 然后它会作为实参被传入； reflect.TypeOf 通过解包该空接口来还原其类型信息。<br>当然， reflect.ValueOf 函数也会还原它的值（从这里开始， 我们会略过那些概念示例，而只关注于可执行的代码）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">fmt.Println(<span class="string">"value:"</span>, reflect.ValueOf(x))</span><br></pre></td></tr></table></figure>
<p>会打印出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value: <span class="number">3.4</span></span><br></pre></td></tr></table></figure>
<p>reflect.Type 和 reflect.Value 都有许多方法来让我们检测并操作它们。 一个重要的例子就是 Value 拥有一个 Type 方法，它会返回 reflect.Value 的 Type 。另外就是 Type 和 Value 都有一个 Kind 方法，它会返回一个常量来表明条目的类型： Uint 、 Float64 或 Slice 等等。同样， Value 拥有像 Int 和 Float 这样的方法来让我们获取存储在内部的值 （作为 int64 和 float64 ）:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">"type:"</span>, v.Type())</span><br><span class="line">fmt.Println(<span class="string">"kind is float64:"</span>, v.Kind() == reflect.Float64)</span><br><span class="line">fmt.Println(<span class="string">"value:"</span>, v.Float())</span><br></pre></td></tr></table></figure>
<p>会打印出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span>: <span class="keyword">float64</span></span><br><span class="line">kind is <span class="keyword">float64</span>: <span class="literal">true</span></span><br><span class="line">value: <span class="number">3.4</span></span><br></pre></td></tr></table></figure>
<p>同样还有 SetInt 和 SetFloat 这样的方法，不过在使用它们之前， 我们需要理解其可设置性，该主题会在后面的第三条反射法则中讨论。<br>反射库有几点特性值得一提。首先，为了让 API 保持简单， Value 的“获取者”和“设置者”方法会在能够保存其值的最大类型上进行操作：例如 int64 就能用于所有的带符号整数。也就是说， Value 的 Int 方法会返回 int64 类型的值，而 SetInt 会接受 int64 类型的值；因此该值可能需要转换为它所涉及到的实际类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">uint8</span> = <span class="string">'x'</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">"type:"</span>, v.Type())                            <span class="comment">// uint8.</span></span><br><span class="line">fmt.Println(<span class="string">"kind is uint8: "</span>, v.Kind() == reflect.Uint8) <span class="comment">// true.</span></span><br><span class="line">x = <span class="keyword">uint8</span>(v.Uint())                                       <span class="comment">// v.Uint returns a uint64.</span></span><br></pre></td></tr></table></figure>
<p>第二个特性就是反射对象的 Kind 描述了其基本类型，而给静态类型。 若反射对象包含了用户定义的整数类型的值，比如</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInt <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> x MyInt = <span class="number">7</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></table></figure>
<p>那么 v 的 Kind 仍为 reflect.Int ，尽管 x 的静态类型为 MyInt 而非 int 。换句话说， Kind 无法区分 int 和 MyInt ，而 Type 则可以。</p>
<h3 id="反射法则二：从反射对象可反射出接口值"><a href="#反射法则二：从反射对象可反射出接口值" class="headerlink" title="反射法则二：从反射对象可反射出接口值"></a>反射法则二：从反射对象可反射出接口值</h3><p>如同物理中的反射现象那样，Go中的反射也会产生它自己的镜像。<br>给定一个 reflect.Value ，我们可以使用 Interface 方法还原其接口值；在效果上，该方法会将类型与值的信息打包成接口表示，并返回其结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Interface 将 v 的值返回成 interface&#123;&#125;。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Value)</span> <span class="title">Interface</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>因此，我们可以通过</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y := v.Interface().(<span class="keyword">float64</span>) <span class="comment">// y will have type float64.</span></span><br><span class="line">fmt.Println(y)</span><br></pre></td></tr></table></figure>
<p>打印出反射对象 v 所表示的 float64 值。<br>不过我们可以做得更好。 fmt.Println 与 fmt.Printf 等都会将实参作为空接口值传递，它们会被包 fmt 进行内部解包， 就像我们刚做的那样。因此，正确地打印出 reflect.Value 内容的方法就是 将 Interface 方法的结果传至格式化打印功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(v.Interface())</span><br></pre></td></tr></table></figure>
<p>（为什么不是 fmt.Println(v) ？因为 v 是个 reflect.Value ，而我们想要的是它保存的具体值。）由于值的类型是 float64 ，如果需要的话，我们甚至可以使用浮点数格式化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"value is %7.1e\n"</span>, v.Interface())</span><br></pre></td></tr></table></figure>
<p>然后就会得到</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.4e+00</span></span><br></pre></td></tr></table></figure>
<p>再次强调，这里无需将 v.Interface() 的结果类型断言为 float64 ， 因为空接口值中拥有具体值的类型信息，而 Printf 则会将它还原。<br>简单来说， Interface 方法就是 ValueOf 函数的镜像， 不过其结果总是静态类型 interface{} 。<br>重申一遍：从接口值可反射出反射对象，反之亦可。</p>
<h3 id="反射法则三：可设置性"><a href="#反射法则三：可设置性" class="headerlink" title="反射法则三：可设置性"></a>反射法则三：可设置性</h3><p>第三条法则是最微妙而令人困惑的，但如果我们从第一条法则开始，还是很容易理解的。<br>这些代码虽然不能工作，但很值得学习（自己也在这里踩过坑）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">v.SetFloat(<span class="number">7.1</span>) <span class="comment">// Error: will panic.</span></span><br></pre></td></tr></table></figure>
<p>如果你运行这段代码，它就会报出神秘的恐慌信息：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>: reflect.Value.SetFloat using unaddressable value</span><br></pre></td></tr></table></figure>
<p>其问题的根源不在于值 7.1 能不能寻址，而在于 v 不可设置。 可设置性是反射值 Value 的一种属性，而且并不是所有的反射值都拥有它。<br>Value 的 CanSet 方法会报告 Value 的可设置性。 在我们的例子中，</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br><span class="line">fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())</span><br></pre></td></tr></table></figure>
<p>会打印出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settability of v: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>对不可设置的 Value 调用 Set 方法会产生错误，但什么是可设置性呢？<br>可设置性有点像可寻址性，不过它更加严格。它是反射对象能否修改其创建之初的真实值的一种属性。 可设置性决定了反射对象是否保存原始条目。当我们执行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">v := reflect.ValueOf(x)</span><br></pre></td></tr></table></figure>
<p>后，就将 x 的一份副本传入了 reflect.ValueOf ， 因此该接口值也就作为传递给 reflect.ValueOf 的实参创建了一份 x 的副本，而非 x 本身。因此，假如语句</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br></pre></td></tr></table></figure>
<p>能够成功执行，它也无法更新 x ，即便 v 看起来创建自 x 。就算它能够更新存储在该反射值中的 x 的副本， x 本身也不会受影响。这是令人困惑且毫无用处的，因此它是非法的。 而可设置性就是用于避免此类问题的属性。<br>这看起来很奇怪，事实却并非如此。它其实就是藏在奇特外表下的一种常见情况。 考虑将 x 传递给一个函数f(x)。<br>我们并不期望 f 能修改 x ，因为我们传入的是值 x 的副本，而非 x 本身。如果我们想让 f 直接修改 x ，就必须向该函数传入 x 的地址（即指向 x 的指针）：f(&amp;x)。<br>这即熟悉又简单，反射也是以相同的方式工作的。如果我们想要通过反射修改 x ，就必须向反射库提供要修改的值的指针。<br>让我们试试吧。首先像平时那样初始化 x ，接着创建指向它的反射值，叫做 p 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x <span class="keyword">float64</span> = <span class="number">3.4</span></span><br><span class="line">p := reflect.ValueOf(&amp;x) <span class="comment">// Note: take the address of x.</span></span><br><span class="line">fmt.Println(<span class="string">"type of p:"</span>, p.Type())</span><br><span class="line">fmt.Println(<span class="string">"settability of p:"</span>, p.CanSet())</span><br></pre></td></tr></table></figure>
<p>目前会输出</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> of p: *<span class="keyword">float64</span></span><br><span class="line">settability of p: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>反射对象 p 并不是可设置的，不过我们也不想设置 p ， 而（实际上）是 *p 。为获得 p 指向的内容，我们调用 Value 的 Elem 方法，它会间接通过指针，并将结构保存到叫做 v 的反射值 Value 中：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v := p.Elem()</span><br><span class="line">fmt.Println(<span class="string">"settability of v:"</span>, v.CanSet())</span><br></pre></td></tr></table></figure>
<p>现在 v 是可设置的反射对象，如输出所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">settability of v: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>由于它代表 x ，因此最终我们可使用 v.SetFloat 来修改 x 的值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v.SetFloat(<span class="number">7.1</span>)</span><br><span class="line">fmt.Println(v.Interface())</span><br><span class="line">fmt.Println(x)</span><br></pre></td></tr></table></figure>
<p>并得到期望的输出：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7.1</span></span><br><span class="line"><span class="number">7.1</span></span><br></pre></td></tr></table></figure>
<p>反射可能很难理解，但语言做了它应该做的，尽管反射类型 Types 和值 Values 隐藏了发生的事情。只要记得反射值需要某些东西的地址来修改它所代表的东西。</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>在我们前面的例子中， v 本身并不是指针，它只是从一个指针中获取的。 在使用反射修改结构体的字段时，这种情况经常出现。即，当我们有结构体的地址时， 就能修改它的字段。<br>下面这个简单的例子分析了结构体类型的值 t 。我们从它的地址创建了反射对象， 因为待会儿要修改它。接着我们将 typeOfT 设置为它的类型， 然后以直白的方法调用遍历其字段（详见 <a href="https://go-zh.org/pkg/reflect/" target="_blank" rel="noopener">reflect</a> 包）。 注意，我们从该结构体类型中提取了其字段名，但字段本身是一般的 reflect.Value 对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> T <span class="keyword">struct</span> &#123;</span><br><span class="line">    A <span class="keyword">int</span></span><br><span class="line">    B <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">t := T&#123;<span class="number">23</span>, <span class="string">"skidoo"</span>&#125;</span><br><span class="line">s := reflect.ValueOf(&amp;t).Elem()</span><br><span class="line">typeOfT := s.Type()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; s.NumField(); i++ &#123;</span><br><span class="line">    f := s.Field(i)</span><br><span class="line">    fmt.Printf(<span class="string">"%d: %s %s = %v\n"</span>, i,</span><br><span class="line">        typeOfT.Field(i).Name, f.Type(), f.Interface())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此程序的输出为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: A <span class="keyword">int</span> = <span class="number">23</span></span><br><span class="line"><span class="number">1</span>: B <span class="keyword">string</span> = skidoo</span><br></pre></td></tr></table></figure>
<p>这里还有一个关于可设置性的要点： T 的字段名必须大写（已导出）， 因为只有已导出的字段才是可设置的。<br>由于 s 包含了可设置的反射对象，因此我们可以修改该结构体的字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s.Field(<span class="number">0</span>).SetInt(<span class="number">77</span>)</span><br><span class="line">s.Field(<span class="number">1</span>).SetString(<span class="string">"Sunset Strip"</span>)</span><br><span class="line">fmt.Println(<span class="string">"t is now"</span>, t)</span><br></pre></td></tr></table></figure>
<p>其结果为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t is now &#123;<span class="number">77</span> Sunset Strip&#125;</span><br></pre></td></tr></table></figure>
<p>若我们将此程序修改为 s 创建自 t 而非 &amp;t ，那么调用 SetInt 和 SetString 就会失败，因为 t 的字段不可设置。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>再次提示，反射法则如下：</p>
<ul>
<li>从接口值可反射出反射对象。</li>
<li>从反射对象可反射出接口值。</li>
<li>要修改反射对象，其值必须可设置。</li>
</ul>
<p>一旦你理解了Go中的这些反射法则，它就会变得更容易使用了，尽管它还是很微妙。 这是个强大的工具，因此除非有必要，否则应当避免或小心使用。</p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/golang/" rel="tag">#golang</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/22/distributed-unique-id/" rel="next" title="常见分布式唯一ID生成策略总结">
                <i class="fa fa-chevron-left"></i> 常见分布式唯一ID生成策略总结
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/15/golang-channel/" rel="prev" title="golang中channel的属性分析">
                golang中channel的属性分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2018/07/22/golang-reflection/"
           data-title="golang反射三法则" data-url="http://blog.jonnydu.me/2018/07/22/golang-reflection/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="jonnydu" />
          <p class="site-author-name" itemprop="name">jonnydu</p>
          <p class="site-description motion-element" itemprop="description">jonnydu.uestc@gmail.com</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">71</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jiongdu" target="_blank">
                  
                    <i class="fa fa-https://github.com/jiongdu"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/3309795495" target="_blank">
                  
                    <i class="fa fa-globe"></i> 微博
                  
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型与接口"><span class="nav-number">2.</span> <span class="nav-text">类型与接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口的表示"><span class="nav-number">3.</span> <span class="nav-text">接口的表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射法则一：反射是从接口值到反射对象"><span class="nav-number">4.</span> <span class="nav-text">反射法则一：反射是从接口值到反射对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射法则二：从反射对象可反射出接口值"><span class="nav-number">5.</span> <span class="nav-text">反射法则二：从反射对象可反射出接口值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反射法则三：可设置性"><span class="nav-number">6.</span> <span class="nav-text">反射法则三：可设置性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体"><span class="nav-number">7.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jonnydu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io" target="_blank" rel="noopener">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"jonnydu"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  


</body>
</html>
