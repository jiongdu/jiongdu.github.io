---
title: C++内存管理--部分总结
date: 2016-04-13 19:11:16
tags: C++
---

可以说，内存管理是c/c++程序员面临的最重要的问题之一，同时很多时候也是最麻烦的事情。所以，这里对简单层次的内存管理做下总结和说明，同时，例举了一些常见的内存错误及解决策略。
<!--more-->
### 野指针     
在c/c++内存问题中经常听到野指针这个词语，那么到底什么事野指针？野指针是怎样形成的？
首先，野指针不是NULL指针，而是指向"垃圾"内存的指针。NULL指针用if语句很容易判断，但是野指针很危险，if语句对其不起作用。
野指针的成因主要有下列几种：      
(1) 指针变量没有初始化。 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。   
(2) 指针被free()或者delete之后，没有置为NULL，让人误以为其是个合法的指针。  这点是实际运用过程中极易犯错误的。    
(3) 指针操作超越了变量的作用范围。
### new/delete和malloc()/free()

c/c++程序员想必不会陌生。注意它们的区别和联系。    
(1) new/delete是c++的操作符,而malloc()/free()是c/c++的一个函数。    
(2) new不只是内存分配，在内存分配后，还会调用类的构造函数，同样，delete会调用类的析构函数。而malloc()只分配内存，不初始化成员，free也不会调用析构函数。所以，new可以认为是malloc()加构造函数的执行。   
(3) 因为new会调用类的构造函数，所以new出来的指针式直接带类型信息的，而malloc()返回的都是void指针。  
(4) 同样的原因，对于非内部数据类型的对象而言，只用malloc()/free()无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，在消亡之前要自动执行析构函数。由于malloc()/free()是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc()/free()。而由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc()/free()和new/delete是等价的。    
(5) 如果用free()释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。同样，用delete释放"malloc()申请的动态内存"。理论上讲程序不会出错，但是该程序的可读性很差。所以，new/delete必须配对使用，malloc()/free()也一样。
                                           
                                                                 
一些易错点：
(1) malloc()函数本身并不识别要申请的内存是什么类型，而只关心内存的总字节数。malloc()返回值的类型是void*,*所以在调用malloc()时要显示地进行类型转换，将void*转换成所需要的指针类型。    
(2) 语句free(p)之所以能正确地释放内存.是因为指针p的类型以及它所指的内存的容量事先都是知道的。如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。     
(3) 运算符new使用起来要比函数malloc简单得多，这是因为new内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。如果对象有多个构造函数，那么new的语句也可以有多种形式。而如果用new创建对象数组，那么只能使用对象的无参数构造函数。          


### 常见的内存错误及策略

**(1) 内存分配未成功，却使用了它**    
编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行检查。如果是用malloc()或new()来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。    
(2) 内存分配虽然成功，但是尚未初始化就引用它     
犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。     
内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。         
**(3) 内存分配成功并且已经初始化，但操作越过了内存的边界**      
例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。       
**(4) 忘记了释放内存，造成内存泄露**      
 含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。   
**(5) 释放了内存却继续使用它（常见有三种情况）**    
a. 程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。 
b. 函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。
c. 使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。

以上是对常见的一些内存问题的解决策略的总结。错误率特别高的部分已经用黑体标出，需注意。
  
### 指针和数组的对比
指针和数组应该是c/c++程序员在编程过程中常打交道的类型了。而且二者在不少地方还可以相互替换着用，但是，请注意，二者有很大的区别。下面对c/c++指针和数组使用中注意项和易错项做下总结。(下述中p是指指针，a、b指数组)      
(1) 数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。     
(2) 若想把数组a的内容复制给数组b，不能用语句 b = a ，应该用标准库函数strcpy()进行复制。       
(3) 比较数组b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。    
(4) 语句p = a 不是把a的内容复制指针p，而是把a的地址赋给了p。可以先用库函数malloc()为p申请一块容量为strlen(a)+1个字符的内存，再用strcpy()进行字符串复制。       
(5) 语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp()来比较。     
(6) 用运算符sizeof可以计算出数组的容量（字节数）（注意别忘了’\0’）。 
(7) c/c++没有办法知道指针所指的内存容量，除非在申请内存时记住它。   
(8) 当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。(即在函数内的用数组名的本质上是相应的指针)


### 指针函数的传递
函数参数是指针时，在指针参数的传递时需要注意：
(1) 函数的参数是一个指针，不能用该指针去申请动态内存。    
(2) 如果非得要使用指针参数去申请内存，那么应该改用"指向指针的指针"。

    void GetMemory(char **p, int num)
	{ 
		*p = (char *)malloc(sizeof(char) * num);
	} 
	void Test(void)
	{ 
		char *str = NULL;
  		GetMemory(&str, 100);   //参数是&str
		strcpy(str, "hello");
   		cout<< str << endl;
   		free(str);
	}
(3) 由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单。

    char *GetMemory(int num)
	{ 
		char *p = (char *)malloc(sizeof(char) * num); return p;	
	} 
	void Test(void)
	{ 
		char *str = NULL;
 		str = GetMemory3(100);
  		strcpy(str, "hello");
  		cout<< str << endl;
  		free(str);
	}

### 待续
内存管理是c/c++的最重要的问题之一，这里只是简单的对常见的内存分配与回收、内存错误及解决策略、指针和数组等问题进行了分析和总结。这部分理论较多，需很好的理解与掌握。 要是能自己再结合实际分析一下，就能更好地理解、掌握了。      
以上，只是c/c++内存管理的一角，后面还将更深入探讨。
