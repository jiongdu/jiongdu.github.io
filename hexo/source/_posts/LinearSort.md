---
title: 线性排序算法：计数排序、基数排序和桶排序
date: 2016-09-07 20:43:51
tags: 数据结构与算法
---

在计算机科学中，排序是一个非常基础的算法。不同的排序算法有不同的时间和空间开销。在这么多的排序算法中，根据在排序的最终结果中，各元素的次序是否依赖于它们之间的比较，可以将排序算法分为两大类：基于比较的排序和非基于比较的排序。
<!--more-->   
基于比较的排序需要对序列中的数据进行比较，如我们最常用的快速排序、堆排序和归并排序。根据决策树模型可以证明：基于比较的排序算法的时间复杂度是不能突破O(NlogN)的。（《算法导论》8.1）                
而非基于比较的排序，如本文将要介绍的计数排序、基数排序和桶排序，则可以突破O(NlogN)的时间下限。当然，这样的非比较的排序的使用会有一些条件的限制，比如元素的大小，所以，在一般在特定场合下，非基于比较的排序算法能够巧妙地解决一些问题。     

### 计数排序
首先介绍计数排序。    
计数排序假设n个输入元素的每一个都是在0到K区间内的一个整数，其中K为某个正整数。计数排序的基本思想是，对每一个输入元素x，确定小于x的元素个数。利用这一信息，就可以直接把x放到它在输出数组的位置上了。比如，如果有17个元素小于x，则x就应该放在第18（或17，看数组a[0]怎么处理）个输出位置上。    
按照这个思想，可以写出计数排序的伪代码：    
	
	COUNTING-SORT(A,B,k)
		let C[0,k] be a new array
		for i=0 to k
			C[i]=0
		for j=0 to A.length-1
			C[A[j]]=C[A[j]]+1
		for i=1 to k
			C[i]=C[i]+C[i-1]
		for j=A.length-1 to 0
			B[C[A[j]]-1]=A[j]
			C[A[j]]=C[A[J]]-1

说明一下，《算法导论》中的伪代码采用的是输入数组为A[1..n],输出数组为B[1..n]。这里没有这样做，而是采用传统的0~n-1的数组下标作为输入输出，本质是一样的。     

下面以数据2 5 3 0 2 3 0 3为例说明计数排序的执行过程。
![](http://i.imgur.com/pgoZnNn.png)
![](http://i.imgur.com/Yz80C5w.png)
![](http://i.imgur.com/hvHJ4Lx.png)   
容易看出，第一个for循环所花时间为Θ(k)，第二个for循环所花时间为Θ(n)，第三个for循环所花时间为Θ(k)，最后一个循环所花时间为Θ(n)。这样，总的时间代价就是Θ(n+k)。所以，当k=O(n)时，一般可以采用计数排序，这时运行时间为Θ(n)。          

### 桶排序
桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为O(n)。与计数排序类似，因为对输入数据做了某种假设，桶排序的速度也很快。具体来说，计数排序假设输入数据都属于一个小区间内的整数，而桶排序则假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上。我们把区间[0,1)划分成n个相同大小的子区间，称为桶。将n个记录分布到各个桶中去。如果有多于一个记录分到同一个桶中，需要进行桶内排序。          
在桶排序的代码中，假设输入是一个包含n个元素的数组A，且每个元素A[i]满足0<=A[i]<1。此外，算法还需要一个临时数组B[0..n-1]来存放链表（即桶），并假设存在一种用于维护这些链表的机制。在分完桶后，对每个桶进行排序，然后合并最后的结果。         
桶排序用伪代码表示如下：
	
	BUCKET-SORT(A)
		n=A.length
		let B[0..n-1] to be a new array
		for i=0 to n-1
			make B[i] an empty list
		for i=1 to n
			insert A[i] to list B[nA[i]]
		for i=0 to n-1
			sort list B[i] with insertion sort
		concatenate the list B[0],B[1],...,B[n-1] together in order
例如，要对大小为[1..1000]范围内的n个整数A[1,n]排序，可以把桶设为大小为10的范围，具体而言，设集合B[0]存储[1..10)的整数，集合B[2]存储(10,20]的整数...依次，总共有100个桶。然后对A[1,n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。然后再对这100个桶中每个桶里的数字进行排序。最后依次输出每个桶里面的数字，这样得到的就是排好序的序列了。    
桶排序的平均时间复杂度为线性的O(N+C)，其中C为桶内快排的时间复杂度，如果对于同样的N，桶数量M越大，其效率越大，最好的时间复杂度达到O(N)。但是，桶排序的空间复杂度为O(N+M)，如果输入数据很庞大，而桶的数量也非常多，则空间代价是昂贵的。 

### 基数排序    

另外一种线性排序方式是基数排序。下面通过一个例子来说明基数排序的思想。     
假设有待排序的数据序列如下：
73 22 93 43 55 14 28 65 39 81    
首先根据个位数的数值，在遍历数据时将它们各自分到编号为0-9的桶中，分配的结果如下图所示：            
 ![](http://i.imgur.com/eOVN7vZ.png)      
分配结束后，接下来将所有桶中所盛数据按照桶号由小到大依次重新收集起来，得到下列仍然无序的数据序列：     
81 22 73 93 43 14 55 65 28 39     
接着，再进行一次分配，这次根据十位数值来分配（原理同上），分配结构如下所示。             
![](http://i.imgur.com/sLQPdaX.png)    
这样，原来无序的数据序列已经排序完毕。如果排序的位数大于2，则重复以上动作至最后一位。  
当然，上面的排序过程中有一个还需探究的问题，即在原来的序列中的73 93 43（个位数相同）三个数的顺序，在经过第一次分配之后，在桶中的顺序由底至上应该为73 93 43（即装的迟的在最上面），但是在3号桶中刚好相反。这正是基数排序稳定的原因，分配时是从预排数据序列的末尾开始进行，逐次分配至首位。      
所以，不难看出，基数排序原理类似于桶排序，只是这里总是需要十个桶，多次使用。     
	

	/*
	 * getdigit(arr[i],k)用于获得arr[i]第k位上的数字
	 */
	
	void lsdRadixSort(int arr[], int begin, int end, int d)
	{
		const int radix = 10;
		int count[radix];
		int i,j;
		
		int *bucket = (int*)malloc((end-start+1)*sizeof(int));
		for(int k=1;k<=d;k++)
		{
			for(i=0;i<radix;i++)
			{
				count[i]=0;
			}
			for(i=begin;i<=end;i++)
			{
				count[getdigit(arr[i], k)]++;	
			}	
			for(i=1;i<radix;i++)
			{
				count[i] = count[i] + count[i-1];
			}
			for(i=end;i>=end;--i)
			{
				j = getdigit(arr[i], k);
				bucket[count[j]-1] = arr[i];
				--count[j];
			}
			for(i=begin,j=0;i<=end;++i,++j)
			{
				arr[i] = bucket[j];
			}
		}
		free(bucket);	
	}			

所以，给定n个d位数，其中每一个数位有k个可能的取值，所以，每一轮排序耗时Θ(n+k)，那么整个基数排序的总时间为Θ(d(n+k))，当d为常数且k=O(n)时，基数排序具有线性的时间代价。

### 总结
以上三种线性时间排序方法突破了基于比较排序的O(NlogN)的时间下界，这样的非比较排序的方法会有一些使用场景的限制，比如元素的大小，所以，在特定的条件下，会体现出较好的性能。     
本质上，都体现了用空间换时间的理念。        