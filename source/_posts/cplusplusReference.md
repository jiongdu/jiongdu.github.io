---
title: C++引用剖析
date: 2016-09-14 19:58:41
tags: C++
---

引用是C++对于C语言的一个强有力的补充，它是对象的别名，这里的对象是指广义的，不仅是用类、结构体等复杂类型来声明的变量，还包括用int，float等简单类型声明的变量。引用在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命期是不能被改变的，即自始至终只能依附于同一个变量。     
<!--more-->

### C++引用的本质
C++引用的本质是指针常量。      
引用是个常量，不同于指针，其在声明时必须初始化。此外，引用其实也是一种指针，绑定于自身的指针。只不过二者的接口并不相同，引用的接口有一定的限制，下述。
	
	struct A
	{
		char name_;
		int num_;
		A& a_;
	};    
	
	struct B
	{
		int num_;
		B& b_;
	};
	
	int main()
	{
		cout << sizeof(A) << endl;		//12
		cout << sizeof(B) << endl;		//8
	}

32位平台下，运行上述测试代码，可以看出两个结构中对自身的引用占四个字节，是与对象的一种绑定关系，通过引用可以获得对象。

### 指针和引用的区别  

虽然引用很多时候表现出指针的特性，但是二者是有很大区别的。    
首先，引用不可以为空，但指针可以为空。前面说过，引用是对象的别名，若对象不存在，怎么可能有别名？所以，定义一个引用的时候，必须初始化。而如果有一个变量是用于指向另一个对象，但是它可能为空，这时应该使用指针。因此，在实际代码编写中，使用指针之前必须做判空操作(`if(!p==NULL)`)，而引用就不必。    
其次，引用不可以改变指向，始终绑定同一个对象，这也正是上述常量指针的表现。而指针可以改变指向。需要注意的是，虽然引用不可以改变指向，但是可以改变初始化对象的内容。
	
	int i = 10;
	int& ref = i;
	ref++;
	cout << "i " << i << " ref " << ref << endl;

	int j = 20;
	ref = j;
	ref++;
	cout << "i " << i << " ref " << ref << " j " << j << endl;
 
输出为：     
![](http://i.imgur.com/qgy7FOO.png)
可以看出，对ref的++操作是直接反应到所绑定变量之上，所以，第一个cout之后i和ref都变为了11，对ref重新赋值并不影响它的指向。，它仍然指向的是i，而不是j，只是其绑定变量的值变为了j的值20，然后再对ref++，最终，i和ref都变为了21，而j，仍然是20。      
第三，引用的大小是所绑定的变量的大小，因为引用只是一个别名而已；而指针对应的是指针本身的大小，4个字节（32bits）。    
	
	struct	A
	{
		char name_;
		int num_;
		int sum_
	};	
	
	int main()
	{
		A a;
		A& ref = a;
		cout << sizeof(ref) << endl;  //12
		A* p = new A();
		cout << sizeof(p) << endl;    //4
	}
最后，引用比指针更安全。因为不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用，因此引用很安全。而对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。       
总而言之---指针指向一块内存，它的内容是指向内存的地址；而引用则是某块内存的别名，引用不改变指向。

### const
很多C++程序员一提到const就头疼，特别是对常量指针、指针常量、常量指针常量等概念，现在还要加上引用...     
首先总结下如何判定const是修饰指针，还是修饰指针所指向的数据。有一个简单的规则，画一条垂直穿过指针声明星号(*)的线，如果const出现在线的左边，则指针指向的数据位常量；如果const出现在右边，指针本身为常量。   
#### 常量指针和常量引用
常量指针：指向常量的指针，表示指向的对象是常量。比如`const int* p = &a`，即告诉编译器\*p是常量，不能将\*p作为左值进行操作。      
常量引用：指向常量的引用，表示指向的对象是常量。和指针一样不能利用引用对指向的变量进行重新赋值操作。
    
	int main()
	{   
		int i = 10;    
		const int& ref = i;      
		ref = 20; 			//error    
	}

#### 指针常量和引用常量
指针常量：表示指针本身是常量，所以，在定义指针常量时必须进行初始化。比如`int* const p = &b`，即告诉编译器，p是常量，不能作为左值进行操作，但是允许修改间接访问值，即*p可以修改。    
引用常量：这是引用天生俱来的属性，不用再引用const来定义。   
#### 常量指针常量和常量引用常量
常量指针常量：指向常量的指针常量，如`const int* const p = &c`，告诉编译器，p和*p都是常量，他们都不能作为左值进行操作。    
不存在所谓的“常量引用常量”，因为跟上面讲的一样，引用变量就是引用常量。C++不区分变量的const引用和const变量的引用。绝不能给引用本身重新赋值，使它指向另一个变量，因此引用总是const的。如果对引用应用关键字const，起作用就是使其目标成为const变量。即没有：`const int const& a = 1`,只有`const int& a = 1`。     
   
### 指针传递和引用传递
最后，介绍一下指针传递参数和引用传递参数的区别。      
指针传递参数本质上是值传递方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。     
引用传递的过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。所以，被调函数对形参做的任何操作都影响了主调函数中的实参变量。     
所以，对于指针传递的参数，如果改变被调函数中的指针地址，它影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关指针变量，那就得使用指向指针的指针，或者指针引用。
下面以一个代码来说明指针传递和引用传递的区别。  

	void func1(int x)
	{
		x = x + 1;
	}
	
	void func2(int *x)
	{
		(*x) = (*x) + 1;
	}
	
	void func3(int& x)
	{
		x = x + 1;
	}
	
	int main()
	{
		int a = 0;
		func1(a);
		cout << a << endl;	//0
		int b = 0;
		func2(&b);			
		cout << b << endl;	//1
		int c = 0;
		func(c);		
		cout << c << endl;	//1
	}
三个函数分别对应值传递、指针传递和引用传递，值传递中，函数体内的x是外部变量的一份拷贝，改变x不会影响a。而指针传递中，函数体内的x是指向外部b的指针，改变该指针的内容将导致b值改变。引用传递中，函数体内的x是外部变量的引用，即二值是同一个东西，改变x等于改变c。         
但是，要通过指针参数传递来改变主调函数中的相关指针变量，那就得使用指向指针的指针，或者指针引用。