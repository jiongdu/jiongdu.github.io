---
title: 常见并发网络服务程序设计方案
date: 2016-05-28 10:14:00
tags: [network/linux,muduo]
---
《Unix网络编程(第三版)》(以下简称[UNP])中第三十章"客户/服务器程序设计范式"总结了一些常见的并发网络服务程序设计方案，而随着互联网、大数据等浪潮的兴起，业界对服务器程序的高并发能力、稳定性等提出了更高的要求，客户/服务器程序设计范式也在随着时代的需求而不断改进和提升，下面就对常见的并发网络服务程序设计方案作简单总结。

<!--more-->

### 《Unix网络编程》传统方案
#### 方案0
这并不是并发服务器，正如在[UNP]第一章入门的时间获取客户/服务器程序中所看到的，一次只能服务一个客户。服务器通过循环监听套接字等待连接，在连接建立以后处理所需的逻辑。对应到程序中，服务器和客户端都只是简单的调用socket API，完成连接和处理工作。
#### 方案1
这是传统的并发网络编程方案，也是[UNP]中第一个阐述的并发方案，称之为fork()-per-client或process-per-connection，即为每一个客户连接新建一个子进程(fork())，在子进程调用handler()处理客户业务，从而同时服务多个客户端。      
这种方案适合并发连接数不大、计算响应的工作量远大于fork()的开销等情况，考虑到操作系统对运行服务器的用户能够同时拥有多少子进程的限制和为每个客户现场fork()一个子进程的开销。
#### 方案2
对方案1的优化，采用进程池，即在启动阶段预先派生一定数量的子进程，当各个客户连接到达时，这些子进程立即就能为它们服务。       
这种技术的优点在于无须引入父进程执行fork()的开销就能处理新到的客户。缺点则是父进程必须在服务器启动阶段猜测需要预先派生多少子进程。[UNP]中详细的说明了该方案以及对该方案的一些修订，个人觉得最后一个修订版本是一个较好且实用的方案，即只让父进程调用accept()，然后把所接受的已连接套接字"传递给"（描述符传递）某个子进程，父进程随后关闭这个套接字，由子进程处理，父子进程之间通过管道通信。
#### 方案3
传统Java网络编程方案thread-per-connection，即为每个客户连接新建一个线程，由子线程调用handler()处理客户业务，从而同时服务多个客户端。     
这种方案使用线程来取代子进程，所以开销要比方案1小。
#### 方案4
类似于方案2，对方案3中预先创建线程池，就不再赘述。

### 《Unix网络编程》传统方案总结

上述几种方案都是阻塞式网络编程，程序通常会阻塞在系统调用上。比如，当一个进程/线程阻塞在读网络流的时候，但同时程序又想处理键盘输入，就麻烦了。      
所以，一种常见的方法是使用IO多路复用，使用select/poll/epoll这类的多路选择器（本质是事件驱动），让一个线程能处理多个连接。IO复用其实复用的不是IO连接，而是复用线程。使用IO复用几乎肯定要配合非阻塞IO，而使用非阻塞IO肯定要使用应用层buffer。这样，就诞生了现代网络编程中以事件驱动为核心的Reactor模式，继而出现了一些通用的Reactor库/框架，比如libevent、muduo、Netty等。

### Reactor方案
#### 方案5
基本的单线程Reactor方案，使用IO复用，可以同时服务多个连接，但是由于它是单线程的，比较适合IO密集的应用，不太适合CPU密集型的应用，不能发挥多核硬件的能力。
#### 方案6
类似于[UNP]中的解决方案，建立客户连接后，不在Reactor线程中计算，而是创建一个新线程来计算，可以充分利用多核CPU的优势。这个方案需要考虑的是线程执行的不确定性，即同时创建多个线程去处理同一个连接上收到的多个请求，那么算出结果的次序是不确定的。此外，还有一个连接到来创建线程的开销，可以通过下述方案7中的线程池避免。
#### 方案7
为弥补为每个请求创建线程的缺陷，使用固定大小的线程池解决。全部的IO工作都在一个Reator线程完成，而计算任务交给线程池。这种模型适用于计算任务彼此独立，并且IO压力不大的情况。当IO的压力较大时，一个Reactor线程很可能处理不过来了，就可以考虑下方案8。
#### 方案8
该方案的特点是one loop per thread，如下图所示，有一个main Reactor负责accept()连接，然后把连接挂在某个sub Reactor中，这样该连接的所有操作都在sub Reactor所处的线程中完成。这是muduo和Netty内置的多线程方案。            
![](http://i.imgur.com/kccnUkP.png)
Reactor pool的大小(线程数)通常根据CPU数目确定，这样程序的总体处理能力不会随着连接数增加而下降。此外， 由于一个连接完全由一个线程管理，请求的顺序就有了保证。     
与前面的Reactor+thread pool相比，该方案减少了进出thread pool的两次上下文切换，在把多个连接分散到多个Reactor线程之后，小规模计算可以在当前IO线程完成并返回结果，从而降低响应的延迟。
#### 方案9
将上述两种方案结合，既使用多个Reactor来处理IO，又使用线程池来处理计算，如下图所示。这种方案适合既有突发IO（利用多线程处理多个连接上的IO），又有突发计算的应用(利用线程池把一个连接上的计算任务分配给多个线程去做)。
![](http://i.imgur.com/2bBaThf.png)
#### 方案10
Reactor in processes,采用多进程实现。这是Nginx的内置方案，待后续研究Nginx的时候再详述。

### Reactor方案总结
对上述Reactor模型的方案进行了简单总结，如下图所示。

![](http://i.imgur.com/n4bAxFY.png)

其中,C1和C2是根据实际情况设置的常数，与CPU数目、用户业务有关。



参考: 《Linux多线程服务端编程》